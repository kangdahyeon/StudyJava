package summary;
/**
 * System.out.printf("%d(정수)%s(문자열) %c(문자) %f(실수)");
 * 
 * Scanner 클래스 : 콘솔로부터 기본 타입의 값을 바로 읽을 수 있다.
 * scanner 메소드들은 콜솔에서 데이터를 입력한 후 엔터키를 누르면 동작.
 * scanner.nextLine(); : String타입으로 리턴해줌.
 * 
 * Integer.parseInt : 문자열을 숫자로 변환시킴
 * 
 * 조건제어문 if, switch
 * - if(조건) { 조건이 true일때 실행} else{ 조건이 false일때 실행}
 * 		삼항연산자(if-else문은 치환가능) : char grade = (score > 90) ? 'A' : 'B';
 * - switch문 : 변수가 어떤 값을 갖느냐에 따라 실행(값이 맞는 케이스로 바로 이동)
 * 		switch(변수) {
 * 		case 입력값1:
 * 		case 입력값2:
 * 		break; (브레이크를 만나기 전까지 실행하며, 만나면 바로 빠져나옴)
 * 		continue : 반목문에서만 사용하며, 조건을 만족하면 실행하지않음.값을 거를수있다.
 * Math.random : 임의의 double형의 수(1미만)를 뽑아줌.
 * 
 * 반복문
 * 	- for(int i = 0(변수선언); i < 100(반복횟수 0부터 99까지 이므로 100번 실행.) i++(반복문이 끝나면 1씩 증가) {
 * 		실행문장 }
 * 
 * 	- while(조건식) { 조건식이 true일 경우 실행문 } 조건식이 false면 미실행.
 * 	- do{반복 실행할 문장} while(조건식) : 조건식이 true일 경우 실행, false일 경우 미실행.
 * 		do 안의 문장은 조건과 관계없이 최소 1회는 실행함.
 * 
 * 참조타입 : 배열, 열거, 클래스, 인터페이스 -> 모두 메모리 주소를 저장.
 * 
 * 배열 : 같은 타입의 데이터를 나열하고, 각 데이터에 인덱스를 부여한 자료구조.
 * 	- 선언 : 	타입[]변수;
 * 			타입[]변수 = {초기화값, 만들, 수량, 만큼 };
 * 			타입[]변수 = new 타입[배열수];
 * 	- 값저장:	변수[인덱스] = 값; 
 * 배열 길이 : 배열변수.length;
 * 
 * 다차원배열 : 행열로 이루어진 배열.
 * 	- 선언 : 타입[][]변수 = new 타입[행][렬];
 * 참조타입도 배열 가능. String[] strArray = new String[수량];
 * 	항목간의 문자열 비교는 == 말고 equals() 메소드 사용. 
 * 
 * 배열복사 
 *  - for문 사용법 :
 *  int[]oldIntArray = {1,2,3};
 *  int[]newIntArray = new int[5];
 * 		for(int i = 0; i < oldIntArray.length; i++) {
 *			newIntArray[i] = oldIntArray[i]; }   -> oldIntArray에 든 내용을 for구문으로 빼서 newIntArray에 대입해줌.
 *		for(int i = 0; i < newIntArray.length; i++) {
 *			System.out.print(newIntArray[i] + ", ");} -> newIntArray에 대입 되었는지 확인해보는것.
 *
 *  - System.arraycopy 사용법 :
 *  	System.arraycopy(arr1 , 0 , arr2, arr1.length);
 *  	arr1원본배열, 원본 배열에서 복사할 인덱스 시작점, arr2새 배열, 새 배열에서 붙여넣을 인덱스 시작 지점, 원본배열 길이 로 구성.
 *  
 *  향상된 for문 :
 *  	for(2.타입 변수 : 1.배열) { 3.실행문 }; -> 배열 에서 가져올 항목이 있는지 확인 해서 있으면 타입변수에 저장하고 실행문 실행.
 *  	다시 돌아 1번 확인해서 있으면 변수에 넣고 3번 실행문 실행 반복하다가 배열에 값이 없으면 종료.
 *  
 *  열거타입 (enum) : 관례적으로 첫글자를 대문자로하며, 열거상수는 모두 대문자.
 *  열거타입 변수 = 열거타입.열거상수;
 *  
 *  
 *  
 *  
 *  [클래스]
 *  
 *  	클래스로부터 객체를 생성하려면 new연산자를 사용해줘야함.
 *   구성멤버 : 필드 생성자 메소드
 *   필드 : 변수선언, 생성자 Class clazz = new Class(); 이런거. 메소드 : void methodName(){}
 *   	- 필드 : 객체의 고유 데이터, 객체가 가져야할 부품, 객체의 현재 상태 데이터 저장.
 *   			필드 초기화를 해주지 않으면 정수,실수타입 기본값은 0, 논리 false, 참조 null 할당.
 *   필드 사용은 클래스 객체를 우선 생성해주어야 가능하다.
 *   도트(.)는 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 사용.
 *   
 *   생성자 : new 연산자로 호출되는 중괄호 블록.메소드와 비슷하게 생겼으나 클래스 이름과 동일하며 리턴타입이 없다.
 *    		클래스에서 생성자 선언을 생략하면, 컴파일러가 기본생성자를 자동으로 추가함.
 *   명시적으로 선언한 생성자가 1개라도 있으면 컴파일러는 기본 생성자를 추가하지 않음. 
 *   명시적으로 생성자 선언하는법 : 클래스(매개변수선언, 매개변수선언...){}
 *   클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정됨. 다른 값으로 초기화 하고싶다면 1. 필드를 선언할때 초기값을 주기 2. 생성자에서 초기값을 주기.
 *   생성자의 매개변수 이름을 통상적으로 필드와 동일한 이름을 갖는 매개 변수를 사용함. 이 경우에 필드와 클래스의 매개변수의 이름이 같기 때문에 필드에 접근하기위해 this를 사용해줌.
 *   
 *   생성자 오버로딩 : 매개변수를 달리하는 생성자를 여러 개 선언하는것이고, 매개변수의 타입,개수,선언된 순서가 달라야함.
 *   다른 생성자 호출 : this()는 자신의 다른 생성자를 호출하는 코드로 생성자의 첫줄에서만 허용됨. this의 매개값은 호출되는 생성자의 매개 변수에 맞게 제공해야함.
 *   
 *   this 중복코드 없애는것 : 오버로딩으로 생성자가 여러개로 되면 this(변수, 값 이런식으로 해야함.)
 *   
 *   메소드 : 객체의 동작에 해당하는 중괄호 {}블록. 메소드 선언은 선언부와 실행 블록으로 구성되며  선언부 : [리턴타입, 메소드 이름, 매개 변수 선언] / [실행 블록] 
 *   	매개 변수의 개수를 모를 경우 : 배열타입으로 선언함. -> 배열 생성하지 않고 값의 목록만 넘겨주는 방법 : ... 을 사용해서 선언하기. 예 : int sum2(int ... values){}
 *   
 *   리턴값이 있는 메소드 : 리턴타입이 있는 메소드는 반드시 리턴값을 지정해줘야함.
 *   리턴값이 없는 메소드 : void 메소드이고, 여기서  리턴은 메소드 실행 강제종료가 됌.
 *  
 *  메소드 호출의 방법 : 1. 객체 내부에서 호출 : 
 *  예) method2() 메소드에서 method1() 메소드를 호출하는 방법 
 *  	void method1(String p1, int p2) { 	// method1 생성되어있음.
 *  	}
 *  	void method2() {
 *  		method1("p1할당값",100) ;} 		// method2에서 method1 을 호출해서 사용함.
 *  
 *  [필드]
 *  필드란 ? 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현자 상태 데이터를 저장하는곳.
 *   선언은 중괄호 블록 어디든 가능하나 생성자와 메소드 중괄호 블록 내부에는 선언 될 수 없음. -> 생성자나 메소드의 내부에 선언하면 로컬 변수라서 필드로 쳐주지않음.
 *   필드 사용 : 필드값을 읽고 변경하는 작업. 
 *   클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만, 
 *   클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한뒤 사용. > 선언된 자리에 따라서 사용 할 수 있는 범위가 달라짐.
 *   필드를 선언만 하고 값을 지정해주지 않으면, 기본값으로 지정되며, 정수계열 : 0, 논리 false, 실수계열 0.0, 배열,문자열 null
 *   
 *  [생성자]
 *  new 연산자로 호출되는 중괄호 블록. 선언을 생략하면 기본생성자로 생성되나, 명시적으로 또는 필요한 기능이 있으면 꼭 생성해줘야함.
 *  생성자 ? new 연산자로 클래스로부터 객체를 생성할때 호출되어 객체의 초기화를 담당한다.
 *  	객체 초기화란 : 필드를 초기화 하거나 메소드를 호출해서 객체를 사용할 준비를 하는것. 생성자를 실행하지 않고는 클래스로부터 객체를 만들수없음. 
 *  				생성자가 성공적으로 생성되면, 힙영역에 객체가 생성되고, 객체의 번지가 리턴됌. 번지는 클래스 변수에 저장.
 *  
 *   - 기본생성자 : 
 *   	(public) 클래스() {} 의 구성.
 *   클래스가 public class로 선언되면 기본 생성자에도 public 이 붙지만, 클래스가 public 없이 class로만 선언되면 기본생성자에도 붙지않음.
 *    - 선언 : 클래스(매개변수 선언,) { // 객체의 초기화 코드 }
 *    생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴타입이 없고 클래스와 이름이 동일. 생성자 블록 내부에는 객체 초기화 코드가 작성되는데, 일반적으로 필드에 초기값을 저장하거나
 *    메소드를 호출하여 객체 사용 전에 필요한 준비를 함. 
 *    매개 변수 선언은 생략할수도 있고 여러개를 선언해도 된다. 매개 변수는 new 연산자로 생성자를 호출할때 외부의 값을 내부로 전달하는 역할을 함. 
 *     예) Car myCar = new Car("그랜저", "검정", 300);
 *     2개의 매개값은 String이고, 하나는 int. 
 *   세 매개값을 생성자가 받기 위해서는 다음과 같이 매개 변수를 선언해야함.
 *   pubilc class Car {
 *   Car(String model, String color, int maxSpeed) {} }
 *   클래스에서 생성자가 명시적으로 선언되어 있을 경우엔 반드시 선언된 생성자를 호출해서 객체를 생성해야함.
 *   Car클래스의 경우 생성자 선언이 있기 때문에, 기본 생성자Car()를 호출해서 객체를 생성할 수 없고, Car(String color, int cc) 를 호출해서 객체생성을 해야함.
 *   
 *   - 필드 초기화
 *    클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정.
 *    다른값으로 하는방법 : 필드를 선언할때 초기값 주기, 생성자에서 초기값 주기.
 *    필드 선언하면서 초기값을 주면 모든 객체에 같은 초기값이 들어가며, 객체 생성시점에서 다양한 값들로 초기화 되야하면 생성자에서 초기화를 해줘야함.
 *    예)
 *    pubilc class Korean {
 *    
 *    // 필드
 *    String nation = "대한민국";
 *    String name;
 *    String ssn;
 *    
 *    // 생성자
 *    	public Korean(String n, String s) {
 *    		name = n;
 *    		ssn = s;
 *    	}
 *    }
 *  생성자의 매개변수 이름으로 s와 n을 사용했는데, 매개변수의 이름이 너무 짧으면 가독성이 좋지 않아 보통 초기화 시킬 필드의 이름과 동일하게 사용함.
 *  이럴 경우에 생성자 내부에서 필드로 접근이 안되는데, 그걸 this 로 접근 가능.
 *  객체의 필드는 중요한 몇개의 필드만 매개 변수를 통해 초기화 하고 나머지는 필드 선언시에 초기화 하거나 생성자 내부의 임의의 값 또는 계산된 값으로 초기화하거나, 객체 생성 후에 필드값을 별도로 저장하기도 함.
 *  
 *  
 *  [생성자 오버로딩]
 *  매개변수를 달리하는 생성자를 여러개 선언하는것.
 *   예)
 *   public class Car {
 *   	Car() {}
 *   	Car(String model) {}
 *   	Car(String model, String color) {}
 *   	Car(String model, String color, int maxSpeed) {}
 *   }
 *   오버로딩은 매개변수의 타입과 개수 선언된 순서가 같으면 변수 이름이 바뀌어도 같은걸로 취급함.
 *   타입, 순서가 달라야 오버로딩이 됌.
 *   
 *   다른 생성자 호출 this : 생성자 간의 중복된 코드가 발생할 경우, 필드 초기화 내용을 한 생성자에만 작성하고 this로 호출해서 사용할 수 있음.
 *   this는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄 에서만 허용됌.
 		 생성자의 첫줄에서만 허용? : this쓰기전에 다른 필드를 초기화 한다음에, 다음줄에 this 쓰는건 안된다는 뜻인듯.
 	
 	[메소드]
 	 객체의 동작에 해당하는 중괄호 {} 블록. 중괄호 블록 이름이 메소드 이름이며, 메소드를 호출하면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행됌.
 	 매소드 선언 : 선언부(리턴타입, 메소드이름, 매개 변수 선언)와 실행 블록으로 구성.
 	  - 리턴타입 : 리턴값의 타입을 말하며 리턴값이란 메소드를 실행한 후의 결과값을 말함. 리턴값은 있/없 이나 있을경우 선언부에 명시되어야함.
 	  리턴값 없을때 호출방법 : powerOn(); {} 
 	  리턴값 있을때 호출방법 : double drive(int x, int y ) {}
 	  
 	  매소드 이름 : 숫자로 시작x, $,_만 가능, 소문자 작성, 단어혼합시 뒤의 단어는 대문자로 시작.
 	  매개 변수 선언 : 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용. 필요한 경우가 있고, 필요 없는 경우가 있음.
 	  매개 변수 있는 경우 : double drive(int x, int y) {} -> double result = drive(10, 20);
 	  - 매개 변수의 개수를 모를 경우
 	  	매개 변수를 배열 타입으로 선언한다. int sum1(int[] values) { }
 	  	sum1()메소드를 호출할 때 배열을 넘겨 줌으로서, 배열의 항목 값들을 모두 전달 할 수있음.
 	  	배열을 먼저 생성한다음에 넘겨주지 않고 바로 하려면 int sum2(int ... values) {}
 	   ... 로 선언된 매개 변수의 값은 메소드 호출 시 쉼표로 나열해주면 됌.
 	   int result = sum2(1,2,3);
 	   
 	   [리턴문]
 	   메소드 선언에 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야함. 리턴문이 없으면 컴파일 에러가 발생하며, 리턴문이 실행되면 메소드는 즉시 종료됌.
 	   return 리턴값 : 리턴 타입이거나 리턴 타입으로 변환될 수 있어야함.
 	   void 메소드는 리턴값이 없는데 return해주면 메소드 바로 종료.
 	   
 	   [메소드 호출]
 	   
 	   클래스 내/외부의 호출에 의해 실행됌. 내부 : 메소드 이름으로 호출 / 외부 : 객체 생성 뒤, 참조변수를 이용해서 호풀
 	   - 외부에서 하는법 : Car car = new Car();
 	   				  car.run();
 	   				  car.stop();
 	   				  car.sound(); 이렇게.
 	   				  
 	  객체 내부에서 호출 : 메소드(매개값1,...);
 	  위의 방법은 메소드가 리턴값이 없거나, 있어도 받고 싶지 않을 경우 호출. 
 	  리턴값이 있는 메소드를 호출하고 리턴값을 받고 싶다면 다음과 같이 변수를 선언하고 리턴값을 대입함.
 	  타입 변수 = 메소드(매개값,...); -> 타입 변수에 리턴값이 저장됌. 이럴때 메소클랫드는 리턴타입과 동일하거나 자동 타입 변환이 될 수도 있음.
 	  
 	  객체 외부에서 호출 : 클래스 참조변수 = new 클래스(매개값,...);
 	  객체가 생성되었다면 참조 변수와 함께 도트 연산자를 사용해서 메소드를 호출할 수 있음. 도트 연산자는 객체 접근 연산자로 객체가 가지고 있는 필드나 메소드에 접근할때 사용.
 	  
 	  [메소드 오버로딩]
 	  매개값을 다양하게 받아 처리하기 위해 사용함. println 생각해보면 됌 안에 얼마나 많은 오버로딩이 되어있는지..ㅋ
 	  
 	[인스턴스 멤버와 정적 멤버]
 	클래스에 선언된 필드와 메소드가 모두 객체 내부에 포함되는것은 아님. 포함되지 않는 경우에 대한 설명.
 	 객체의 필드값이 모두 같아야 하는경우 : 정적 멤버로 선언.
 	  - 인스턴스 멤버란 ? 객체를 생성 한 후 사용 할 수 있는 필드와 메소드. 인스턴스 필드, 인스턴스 메소드라고 부름. 
 	  	인스턴스 멤버 선언 : public class Car { 
 	  					// 필드
 	  					 int gas;
 	  					// 메소드
 	  					 void setSpeed(int speed) {}
 	  					 }
 	  					 
 	 gas필드와 setSpeed()매소드는 인스턴스 멤버라서 외부에서 사용하게 되면 Car객체를 생성하고, 참조변수로 접근해야함.
 	 인스턴스 메소드는 객체에 소속된 멤버지만 메소드 영역에 저장되고 공유됌.  
 	 
 	 * 인스턴스란 ? 일반적으로 실행중인 임의의 프로세스 
 	 
 	 객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는것과 마찬가지로, 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용 할 수 있음.
 	 this.model은 자신이 가지고 있는 model 필드라는 뜻. 생성자와 메소드의 매개 변수의 이름이 필드와 동일한 경우 인스턴스 멤버인 필드임을 명시하고자 할때 사용.
 	  - 정적 멤버란 ? static 고정된 이란 의미. 객체를 생성하지 않고 사용 할 수 있는 필드와 메소드.
 	  정적 필드와 정적 메소드를 선언하려면 필드와 메소드 선언 시 static 키워드를 추가적으로 붙이면됌.
 	  
 	  *** 정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로, 클래스 로더가 클래스를 로딩해서 메소드 메모리 영역에 적재 할 때 클래스 별로 관리됩니다. 따라서 클래스의 로딩이 끝나면 바로 사용 할 수 있습니다.***
 	정적 멤버 사용 : 클래스가 메모리로 로딩되면 정적 멤버를 바로 사용 할 수 있는데, 클래스 이름과 함께 도트 연산자로 접근함. 클래스.필드(); , 클래스.메소드(매개값);
 	 			원칙적으로는 클래스.필드(); 클래스.메소드(매개값); 이지만 다음과 같이 객체 참조 변수로도 사용 가능.
 	 			Calculator myCalcu = new Calculator(); -> 할순 있지만 클래스이름.어쩌구 로 하는게 좋음.
 	주의할점 : 정적 메소드를 선언하고 그 안에 인스턴스 필드나 인스턴스 메소드는 사용불가. this도 안됌.
 			정적 메소드에서 인스턴스 멤버 사용하려면 객체먼저 생성해줘야함. main()메소드도 정적 메소드이기때문에 인스턴스 필드와 인스턴스 메소드를 바로 사용불가함.
 	
 	[싱글톤]
 	가끔 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야하는 경우가 있음. 그게 이거고 new 연산자로 생성자를 호출 할 수 없도록 막아야 하기때문에 private 접근 제한자를 붙인다.
 	대신 외부에서 호출 할 수 있는 메소드인 getInstance()를 선언하고 자신의 객체를 리턴해줌.
 	예)
 	public class 클래스 {
 		//정적 필드
 		private static 클래스 singleton = new 클래스();
 		
 		//생성자
 		private 클래스() {}
 		
 		//정적 메소드
 		static 클래스 getInstance() {
 		return singleton;
 		}
 	}
 	
 	getInstance() 메소드는 단 하나의 객체만 리턴하기 때문에 수백개를 호출하더라도 동일한 객체임.
 	
 	[final필드와 상수]
 	 final은 최종적 이라는 뜻을 가지고 있음. 이게 붙으면 프로그램 실행 도중에  수정 할 수 없다는 뜻.
 	 final 타입 필드 = 초기값; -> 수정 불가
 	 상수 : 불변의 값. 그렇다고 해서 final = 상수는 아님. 상수는 파이나 지구의 무게 및 둘레 등 절때 변하지 않는 값이고 final은 내가 필요할때 지정해주는거니까.
 	 상수 이름은 대문자로 작성함. 단어 혼합이름이면 _로 연결.
 	 
 [패키지와 접근 제한자]
	패키지란 ? 물리적인 형태로는 파일 시스템의 폴더. 패키지는 클래스의 일부분으로 클래스를 유일하게 만들어주는 식별자 역할을 함. 약간 성 같이 붙여준다고 생각하면될듯.
	패키지 이름은 모두 소문자로 작성하는것이 관례.
	import문 : 사용하고자 하는 클래스 또는 인터페이스가 다른 패키지 소속일때 사용할거라고 알려주는것.
  - 접근제한자 : 보안 등의 문제로 다른 패키지에서 접근하지 못하도록 하는것. public, protected, private, default 가 있음.
  [Getter / Setter 메소드 ]
  마음대로 수정하지 못하게 막아야 할때, 필드는 막고 메소드를 접근 할 수 있도록 하는것. 
  예로 자동차의 speed같은 경우 음수가 나올 수 없으니 speed 필드의 값은 0으로 고정해놓고, getter/setter로 메소드를 생성해서 그 안에 검증코드까지(0미만일경우 실행을 종료하도록)작성해주면됌.
  - Getter : 메소드를 가공해서 외부로 전달하도록 해줌.
  	예) double getSpeed() {
  		 	double km = speed*1.6;
  		 	return km; }		-> 필드값인 마일을 km단위로 환산 후 외부로 리턴
  		 	
  	필드 타입이 boolean인 경우엔 Getter가 get으로 시작하지 않고 is로 시작함.
  	예) private boolean stop;
  		// Getter
  		 public boolean isStop() {
  		 return stop; }
  		
  		// Setter
  		 public void setStop(boolean stop) {
  		 this.stop = stop; }
  		 
  		 Getter : 변수값을 가져오는 메소드. Setter : 변수 값을 설정하는 메소드.
  		 
  [상속]
  중복 코드를 줄일 수 있음. 게다가 부모 클래스를 수정하면 자식 클래스도 수정됌 유지보수 개꿀 
  extends 뒤에 상속받을 클래스 적으면 상속됌.
  
  - 생성자 호출 : 자식 객체를 생성자면 부모 객체가 먼저 생성된다음에 자식 객체가 생성됌. 
  	자식 생성자를 선언하고, 명시적으로 부모 생성자를 호출하고 싶으면
  	자식클래스(매개변수선언,) { super(매개값,..); } 이렇게 하면됌.
  	super가 생략되면 컴파일러에 의해 super가 자동으로 추가됌. 이거는 자식 생성자의 첫줄에 위치해야함.
  	
  - 메소드 재정의 : 부모클래스의 것을 자식클래스에서 사용할때 자식클래스에 맞게 변경하여 사용하는것.(접근제한을 더 강하게 재정의는 안됌)
  				재정의하면 자식클래스의 메소드만 사용되는데, 부모걸 그대로 써야할 상황에선 super 키워드를 붙여서 호출가능.
  
  final클래스 : 상속안됌 / final메소드 : 재정의 안됌
  protected : 같은패키지와 (다른 패키지일 경우)자식클래스만 접근가능.
  
  [타입 변환과 다형성]
  클래스에도 자동타입변환 : 부모타입 변수 = 자식타입; / 강제 타입변환 : 자식타입 변수 = (자식타입)부모타입; 이 있다.
  
   - 매개 변수의 다형성 : 자동 타입 변환은 주로 메소드를 호출 할 때 발생함. 매개값을 다양화 하기 위해 매개변수에 자식 객체를 지정할 수 도 있음.
  void 부모타입 (자식클래스 변수) { 변수.자식클래스가 재정의한메소드(); } 로 가능.
  
   - 객체 타입 확인 : instanceof 연산자 사용 
    예) public void method(Parent parent) { 
    	if(parent instanceof Child) {
    		Child child = (Child) parent; } }
   	타입을 확인하지 않고 강제 타입 변환을 시도하면 ClassCastException이 발생할 수 있음.
   	
  [추상 클래스]
   말 그대로 추상적인 클래스라는 뜻이다. 내가 만들 것들의 공통적인 부분을 추출해서 만드는 클래스임.
  -	용도 : 공통된 필드와 메소드의 이름을 통일 할 목적.실체 클래스를 작성 할 때 시간 절약됌. 
  
  - 선언 : public abstract class 클래스 { 
  			//필드
  			// 생성자
  			//메소드 
  		 }
  			
  - 추상메소드 : 선언만 동일하고 실행 내용은 달라야 하는 경우엔 선언만 하고 중괄호를 쳐주지않음. abstract 리턴타입 메소드이름(매개변수, ...);
   			 자식 클래스는 추상메소드를 반드시 재정의해서 실행 내용을 작성해야함.
   			 
   			 
   [인터페이스]
  개발 코드와 객체가 서로 통신하는 역할. 인터페이스를 사용하면 개발 코드를 직접 수정하지않고, 사용하는 객체를 변경 할 수 있음. 코드 변경 없이 실행 내용과 리턴값을 다양화 할 수 있다는 장점이 있음.
  interface 인터페이스 이름 {   // 으로 선언. 인터페이스는 생성자를 가질 수 없음.
  	// 상수
  	타입 상수이름 = 값;
  	// 추상메소드
  	타입 메소드이름(매개변수, ...);
 } 
   - 상수 필드 선언 : 상수 필드만 가질 수 있음. 글고 상수이름 대문자인거 잊지마.
   - 추상 메소드 선언 : 실행 불록이 필요없는 추상 메소드로 선언함. 인터페이스에 선언하면 자동으로 추상메소드가 됌.
   
  [인터페이스 구현]
  개발 코드가 인터페이스 메소드를 호출하면 인터페이스는 객체의 메소드를 호출함.객체는 인터페이스에서 정의된 추상 메소드와 동일한 메소드이름, 매개타입, 리턴타입을 가진 실체 메소드를 가지고 있어야함.
  이를 구현 객체라 하며, 구현 객체를 생성하는 클래스를 구현 클래스라고 함.
  
   - 구현 클래스 : 보통의 클래스와 동일하지만 인터페이스 타입으로 사용 할 수 있음을 알려주기위해 선언부에 implements 키워드를 추가함.
     			* 여기서 인터페이스의 추상 메소드에 대한 실체 메소드를 작성할때 주의점은 모든 메소드는 기본적으로 public 접근 제한을 가짐.
     			* 구현 클래스가 작성되면 new 연산자로 객체를 생성할 수 있음.
   
   		인터페이스로 구현객체를 사용하려면 ? 인터페이스 변수; 변수 = 구현객체; / 인터페이스 변수 = 구현객체;
  	다중 인터페이스를 구현 할 경우 구현 클래스는 모든 인터페이스의 추상 메소드에 대해 실체 메소드를 작성해야함.
  	
  	- 인터페이스 사용 : 클래스를 선언할 때 인터페이스는 필드, 생성자 또는 메소드의 매개변수, 생성자 또는 메소드의 로컬 변수로 선언 될 수 있다.
  	예 ) public class MyClass {
  		// 필드
  		RemoteControl rc = new Television();
  		
  		// 생성자
  		MyClass(RemoteControl rc) { -> 생성자의 매개값으로 구현 객체 대입. 이 경우엔 new Television();임.
  			this.rc = rc;
  		// 메소드
  		void methodA() {
  			//로컬변수
  			RemoteControl rc = new Audio(); }
  		
  		void methodB(RemoteControl rc) { } }  -> 생성자의 매개값으로 구현 객체 대입. 이 경우엔 new Audio();인것임.
  	
  		
  	 
  		 
  		 
  		 	
	
 	 
 	  
 	  
 	  
 	  
 	  
 	   
 	   
 	  
 * @author KDH
 *
 */

public class MethodSummary {

}
