package summary;
/**
 * System.out.printf("%d(정수)%s(문자열) %c(문자) %f(실수)");
 * 
 * Scanner 클래스 : 콘솔로부터 기본 타입의 값을 바로 읽을 수 있다.
 * scanner 메소드들은 콜솔에서 데이터를 입력한 후 엔터키를 누르면 동작.
 * scanner.nextLine(); : String타입으로 리턴해줌.
 * 
 * Integer.parseInt : 문자열을 숫자로 변환시킴
 * 
 * 조건제어문 if, switch
 * - if(조건) { 조건이 true일때 실행} else{ 조건이 false일때 실행}
 * 		삼항연산자(if-else문은 치환가능) : char grade = (score > 90) ? 'A' : 'B';
 * - switch문 : 변수가 어떤 값을 갖느냐에 따라 실행(값이 맞는 케이스로 바로 이동)
 * 		switch(변수) {
 * 		case 입력값1:
 * 		case 입력값2:
 * 		break; (브레이크를 만나기 전까지 실행하며, 만나면 바로 빠져나옴)
 * 		continue : 반목문에서만 사용하며, 조건을 만족하면 실행하지않음.값을 거를수있다.
 * Math.random : 임의의 double형의 수(1미만)를 뽑아줌.
 * 
 * 반복문
 * 	- for(int i = 0(변수선언); i < 100(반복횟수 0부터 99까지 이므로 100번 실행.) i++(반복문이 끝나면 1씩 증가) {
 * 		실행문장 }
 * 
 * 	- while(조건식) { 조건식이 true일 경우 실행문 } 조건식이 false면 미실행.
 * 	- do{반복 실행할 문장} while(조건식) : 조건식이 true일 경우 실행, false일 경우 미실행.
 * 		do 안의 문장은 조건과 관계없이 최소 1회는 실행함.
 * 
 * 참조타입 : 배열, 열거, 클래스, 인터페이스 -> 모두 메모리 주소를 저장.
 * 
 * 배열 : 같은 타입의 데이터를 나열하고, 각 데이터에 인덱스를 부여한 자료구조.
 * 	- 선언 : 	타입[]변수;
 * 			타입[]변수 = {초기화값, 만들, 수량, 만큼 };
 * 			타입[]변수 = new 타입[배열수];
 * 	- 값저장:	변수[인덱스] = 값; 
 * 배열 길이 : 배열변수.length;
 * 
 * 다차원배열 : 행열로 이루어진 배열.
 * 	- 선언 : 타입[][]변수 = new 타입[행][렬];
 * 참조타입도 배열 가능. String[] strArray = new String[수량];
 * 	항목간의 문자열 비교는 == 말고 equals() 메소드 사용. 
 * 
 * 배열복사 
 *  - for문 사용법 :
 *  int[]oldIntArray = {1,2,3};
 *  int[]newIntArray = new int[5];
 * 		for(int i = 0; i < oldIntArray.length; i++) {
 *			newIntArray[i] = oldIntArray[i]; }   -> oldIntArray에 든 내용을 for구문으로 빼서 newIntArray에 대입해줌.
 *		for(int i = 0; i < newIntArray.length; i++) {
 *			System.out.print(newIntArray[i] + ", ");} -> newIntArray에 대입 되었는지 확인해보는것.
 *
 *  - System.arraycopy 사용법 :
 *  	System.arraycopy(arr1 , 0 , arr2, arr1.length);
 *  	arr1원본배열, 원본 배열에서 복사할 인덱스 시작점, arr2새 배열, 새 배열에서 붙여넣을 인덱스 시작 지점, 원본배열 길이 로 구성.
 *  
 *  향상된 for문 :
 *  	for(2.타입 변수 : 1.배열) { 3.실행문 }; -> 배열 에서 가져올 항목이 있는지 확인 해서 있으면 타입변수에 저장하고 실행문 실행.
 *  	다시 돌아 1번 확인해서 있으면 변수에 넣고 3번 실행문 실행 반복하다가 배열에 값이 없으면 종료.
 *  
 *  열거타입 (enum) : 관례적으로 첫글자를 대문자로하며, 열거상수는 모두 대문자.
 *  열거타입 변수 = 열거타입.열거상수;
 *  
 *  클래스
 *  	클래스로부터 객체를 생성하려면 new연산자를 사용해줘야함.
 *   구성멤버 : 필드 생성자 메소드
 *   필드 : 변수선언, 생성자 Class clazz = new Class(); 이런거. 메소드 : void methodName(){}
 *   	- 필드 : 객체의 고유 데이터, 객체가 가져야할 부품, 객체의 현재 상태 데이터 저장.
 *   			필드 초기화를 해주지 않으면 정수,실수타입 기본값은 0, 논리 false, 참조 null 할당.
 *   필드 사용은 클래스 객체를 우선 생성해주어야 가능하다.
 *   도트(.)는 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 사용.
 *   
 *   생성자 : new 연산자로 호출되는 중괄호 블록.메소드와 비슷하게 생겼으나 클래스 이름과 동일하며 리턴타입이 없다.
 *    		클래스에서 생성자 선언을 생략하면, 컴파일러가 기본생성자를 자동으로 추가함.
 *   명시적으로 선언한 생성자가 1개라도 있으면 컴파일러는 기본 생성자를 추가하지 않음. 
 *   명시적으로 생성자 선언하는법 : 클래스(매개변수선언, 매개변수선언...){}
 *   클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정됨. 다른 값으로 초기화 하고싶다면 1. 필드를 선언할때 초기값을 주기 2. 생성자에서 초기값을 주기.
 *   생성자의 매개변수 이름을 통상적으로 필드와 동일한 이름을 갖는 매개 변수를 사용함. 이 경우에 필드와 클래스의 매개변수의 이름이 같기 때문에 필드에 접근하기위해 this를 사용해줌.
 *   
 *   생성자 오버로딩 : 매개변수를 달리하는 생성자를 여러 개 선언하는것이고, 매개변수의 타입,개수,선언된 순서가 달라야함.
 *   다른 생성자 호출 : this()는 자신의 다른 생성자를 호출하는 코드로 생성자의 첫줄에서만 허용됨. this의 매개값은 호출되는 생성자의 매개 변수에 맞게 제공해야함.
 *   
 *   this 중복코드 없애는것 : 오버로딩으로 생성자가 여러개로 되면 this(변수, 값 이런식으로 해야함.)
 *   
 *   메소드 : 객체의 동작에 해당하는 중괄호 {}블록. 메소드 선언은 선언부와 실행 블록으로 구성되며  선언부 : [리턴타입, 메소드 이름, 매개 변수 선언] / [실행 블록] 
 *   	매개 변수의 개수를 모를 경우 : 배열타입으로 선언함. -> 배열 생성하지 않고 값의 목록만 넘겨주는 방법 : ... 을 사용해서 선언하기. 예 : int sum2(int ... values){}
 *   
 *   리턴값이 있는 메소드 : 리턴타입이 있는 메소드는 반드시 리턴값을 지정해줘야함.
 *   리턴값이 없는 메소드 : void 메소드이고, 여기서  리턴은 메소드 실행 강제종료가 됌.
 *  
 *  메소드 호출의 방법 : 1. 객체 내부에서 호출 : 
 *  예) method2() 메소드에서 method1() 메소드를 호출하는 방법 
 *  	void method1(String p1, int p2) { 	// method1 생성되어있음.
 *  	}
 *  	void method2() {
 *  		method1("p1할당값",100) ;} 		// method2에서 method1 을 호출해서 사용함.
 *  
 *  
 
 * @author KDH
 *
 */

public class MethodSummary {

}
