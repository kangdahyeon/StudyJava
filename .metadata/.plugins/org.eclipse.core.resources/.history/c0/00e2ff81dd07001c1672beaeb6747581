package summary;
/**
 * System.out.printf("%d(정수)%s(문자열) %c(문자) %f(실수)");
 * 
 * Scanner 클래스 : 콘솔로부터 기본 타입의 값을 바로 읽을 수 있다.
 * scanner 메소드들은 콜솔에서 데이터를 입력한 후 엔터키를 누르면 동작.
 * scanner.nextLine(); : String타입으로 리턴해줌.
 * 
 * Integer.parseInt : 문자열을 숫자로 변환시킴
 * 
 * 조건제어문 if, switch
 * - if(조건) { 조건이 true일때 실행} else{ 조건이 false일때 실행}
 * 		삼항연산자(if-else문은 치환가능) : char grade = (score > 90) ? 'A' : 'B';
 * - switch문 : 변수가 어떤 값을 갖느냐에 따라 실행(값이 맞는 케이스로 바로 이동)
 * 		switch(변수) {
 * 		case 입력값1:
 * 		case 입력값2:
 * 		break; (브레이크를 만나기 전까지 실행하며, 만나면 바로 빠져나옴)
 * 		continue : 반목문에서만 사용하며, 조건을 만족하면 실행하지않음.값을 거를수있다.
 * Math.random : 임의의 double형의 수(1미만)를 뽑아줌.
 * 
 * 반복문
 * 	- for(int i = 0(변수선언); i < 100(반복횟수 0부터 99까지 이므로 100번 실행.) i++(반복문이 끝나면 1씩 증가) {
 * 		실행문장 }
 * 
 * 	- while(조건식) { 조건식이 true일 경우 실행문 } 조건식이 false면 미실행.
 * 	- do{반복 실행할 문장} while(조건식) : 조건식이 true일 경우 실행, false일 경우 미실행.
 * 		do 안의 문장은 조건과 관계없이 최소 1회는 실행함.
 * 
 * 참조타입 : 배열, 열거, 클래스, 인터페이스 -> 모두 메모리 주소를 저장.
 * 
 * 배열 : 같은 타입의 데이터를 나열하고, 각 데이터에 인덱스를 부여한 자료구조.
 * 	- 선언 : 	타입[]변수;
 * 			타입[]변수 = {초기화값, 만들, 수량, 만큼 };
 * 			타입[]변수 = new 타입[배열수];
 * 	- 값저장:	변수[인덱스] = 값; 
 * 배열 길이 : 배열변수.length;
 * 
 * 다차원배열 : 행열로 이루어진 배열.
 * 	- 선언 : 타입[][]변수 = new 타입[행][렬];
 * 참조타입도 배열 가능. String[] strArray = new String[수량];
 * 	항목간의 문자열 비교는 == 말고 equals() 메소드 사용. 
 * 
 * 배열복사 
 *  - for문 사용법 :
 *  int[]oldIntArray = {1,2,3};
 *  int[]newIntArray = new int[5];
 * 		for(int i = 0; i < oldIntArray.length; i++) {
 *			newIntArray[i] = oldIntArray[i]; }   -> oldIntArray에 든 내용을 for구문으로 빼서 newIntArray에 대입해줌.
 *		for(int i = 0; i < newIntArray.length; i++) {
 *			System.out.print(newIntArray[i] + ", ");} -> newIntArray에 대입 되었는지 확인해보는것.
 *
 *  - System.arraycopy 사용법 :
 *  	System.arraycopy(arr1 , 0 , arr2, arr1.length);
 *  	arr1원본배열, 원본 배열에서 복사할 인덱스 시작점, arr2새 배열, 새 배열에서 붙여넣을 인덱스 시작 지점, 원본배열 길이 로 구성.
 *  
 *  향상된 for문 :
 *  	for(2.타입 변수 : 1.배열) { 3.실행문 }; -> 배열 에서 가져올 항목이 있는지 확인 해서 있으면 타입변수에 저장하고 실행문 실행.
 *  	다시 돌아 1번 확인해서 있으면 변수에 넣고 3번 실행문 실행 반복하다가 배열에 값이 없으면 종료.
 *  
 *  열거타입 (enum) : 관례적으로 첫글자를 대문자로하며, 열거상수는 모두 대문자.
 *  열거타입 변수 = 열거타입.열거상수;
 *  
 *  
 *  
 *  
 *  [클래스]
 *  
 *  	클래스로부터 객체를 생성하려면 new연산자를 사용해줘야함.
 *   구성멤버 : 필드 생성자 메소드
 *   필드 : 변수선언, 생성자 Class clazz = new Class(); 이런거. 메소드 : void methodName(){}
 *   	- 필드 : 객체의 고유 데이터, 객체가 가져야할 부품, 객체의 현재 상태 데이터 저장.
 *   			필드 초기화를 해주지 않으면 정수,실수타입 기본값은 0, 논리 false, 참조 null 할당.
 *   필드 사용은 클래스 객체를 우선 생성해주어야 가능하다.
 *   도트(.)는 객체가 가지고 있는 필드나 메소드를 사용하고자 할 때 사용.
 *   
 *   생성자 : new 연산자로 호출되는 중괄호 블록.메소드와 비슷하게 생겼으나 클래스 이름과 동일하며 리턴타입이 없다.
 *    		클래스에서 생성자 선언을 생략하면, 컴파일러가 기본생성자를 자동으로 추가함.
 *   명시적으로 선언한 생성자가 1개라도 있으면 컴파일러는 기본 생성자를 추가하지 않음. 
 *   명시적으로 생성자 선언하는법 : 클래스(매개변수선언, 매개변수선언...){}
 *   클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정됨. 다른 값으로 초기화 하고싶다면 1. 필드를 선언할때 초기값을 주기 2. 생성자에서 초기값을 주기.
 *   생성자의 매개변수 이름을 통상적으로 필드와 동일한 이름을 갖는 매개 변수를 사용함. 이 경우에 필드와 클래스의 매개변수의 이름이 같기 때문에 필드에 접근하기위해 this를 사용해줌.
 *   
 *   생성자 오버로딩 : 매개변수를 달리하는 생성자를 여러 개 선언하는것이고, 매개변수의 타입,개수,선언된 순서가 달라야함.
 *   다른 생성자 호출 : this()는 자신의 다른 생성자를 호출하는 코드로 생성자의 첫줄에서만 허용됨. this의 매개값은 호출되는 생성자의 매개 변수에 맞게 제공해야함.
 *   
 *   this 중복코드 없애는것 : 오버로딩으로 생성자가 여러개로 되면 this(변수, 값 이런식으로 해야함.)
 *   
 *   메소드 : 객체의 동작에 해당하는 중괄호 {}블록. 메소드 선언은 선언부와 실행 블록으로 구성되며  선언부 : [리턴타입, 메소드 이름, 매개 변수 선언] / [실행 블록] 
 *   	매개 변수의 개수를 모를 경우 : 배열타입으로 선언함. -> 배열 생성하지 않고 값의 목록만 넘겨주는 방법 : ... 을 사용해서 선언하기. 예 : int sum2(int ... values){}
 *   
 *   리턴값이 있는 메소드 : 리턴타입이 있는 메소드는 반드시 리턴값을 지정해줘야함.
 *   리턴값이 없는 메소드 : void 메소드이고, 여기서  리턴은 메소드 실행 강제종료가 됌.
 *  
 *  메소드 호출의 방법 : 1. 객체 내부에서 호출 : 
 *  예) method2() 메소드에서 method1() 메소드를 호출하는 방법 
 *  	void method1(String p1, int p2) { 	// method1 생성되어있음.
 *  	}
 *  	void method2() {
 *  		method1("p1할당값",100) ;} 		// method2에서 method1 을 호출해서 사용함.
 *  
 *  [필드]
 *  필드란 ? 객체의 고유 데이터, 객체가 가져야 할 부품, 객체의 현자 상태 데이터를 저장하는곳.
 *   선언은 중괄호 블록 어디든 가능하나 생성자와 메소드 중괄호 블록 내부에는 선언 될 수 없음. -> 생성자나 메소드의 내부에 선언하면 로컬 변수라서 필드로 쳐주지않음.
 *   필드 사용 : 필드값을 읽고 변경하는 작업. 
 *   클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만, 
 *   클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한뒤 사용. > 선언된 자리에 따라서 사용 할 수 있는 범위가 달라짐.
 *   필드를 선언만 하고 값을 지정해주지 않으면, 기본값으로 지정되며, 정수계열 : 0, 논리 false, 실수계열 0.0, 배열,문자열 null
 *   
 *  [생성자]
 *  new 연산자로 호출되는 중괄호 블록. 선언을 생략하면 기본생성자로 생성되나, 명시적으로 또는 필요한 기능이 있으면 꼭 생성해줘야함.
 *  생성자 ? new 연산자로 클래스로부터 객체를 생성할때 호출되어 객체의 초기화를 담당한다.
 *  	객체 초기화란 : 필드를 초기화 하거나 메소드를 호출해서 객체를 사용할 준비를 하는것. 생성자를 실행하지 않고는 클래스로부터 객체를 만들수없음. 
 *  				생성자가 성공적으로 생성되면, 힙영역에 객체가 생성되고, 객체의 번지가 리턴됌. 번지는 클래스 변수에 저장.
 *  
 *   - 기본생성자 : 
 *   	(public) 클래스() {} 의 구성.
 *   클래스가 public class로 선언되면 기본 생성자에도 public 이 붙지만, 클래스가 public 없이 class로만 선언되면 기본생성자에도 붙지않음.
 *    - 선언 : 클래스(매개변수 선언,) { // 객체의 초기화 코드 }
 *    생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴타입이 없고 클래스와 이름이 동일. 생성자 블록 내부에는 객체 초기화 코드가 작성되는데, 일반적으로 필드에 초기값을 저장하거나
 *    메소드를 호출하여 객체 사용 전에 필요한 준비를 함. 
 *    매개 변수 선언은 생략할수도 있고 여러개를 선언해도 된다. 매개 변수는 new 연산자로 생성자를 호출할때 외부의 값을 내부로 전달하는 역할을 함. 
 *     예) Car myCar = new Car("그랜저", "검정", 300);
 *     2개의 매개값은 String이고, 하나는 int. 
 *   세 매개값을 생성자가 받기 위해서는 다음과 같이 매개 변수를 선언해야함.
 *   pubilc class Car {
 *   Car(String model, String color, int maxSpeed) {} }
 *   클래스에서 생성자가 명시적으로 선언되어 있을 경우엔 반드시 선언된 생성자를 호출해서 객체를 생성해야함.
 *   Car클래스의 경우 생성자 선언이 있기 때문에, 기본 생성자Car()를 호출해서 객체를 생성할 수 없고, Car(String color, int cc) 를 호출해서 객체생성을 해야함.
 *   
 *   - 필드 초기화
 *    클래스로부터 객체가 생성될 때 필드는 기본 초기값으로 자동 설정.
 *    다른값으로 하는방법 : 필드를 선언할때 초기값 주기, 생성자에서 초기값 주기.
 *    필드 선언하면서 초기값을 주면 모든 객체에 같은 초기값이 들어가며, 객체 생성시점에서 다양한 값들로 초기화 되야하면 생성자에서 초기화를 해줘야함.
 *    예)
 *    pubilc class Korean {
 *    
 *    // 필드
 *    String nation = "대한민국";
 *    String name;
 *    String ssn;
 *    
 *    // 생성자
 *    	public Korean(String n, String s) {
 *    		name = n;
 *    		ssn = s;
 *    	}
 *    }
 *  생성자의 매개변수 이름으로 s와 n을 사용했는데, 매개변수의 이름이 너무 짧으면 가독성이 좋지 않아 보통 초기화 시킬 필드의 이름과 동일하게 사용함.
 *  이럴 경우에 생성자 내부에서 필드로 접근이 안되는데, 그걸 this 로 접근 가능.
 *  객체의 필드는 중요한 몇개의 필드만 매개 변수를 통해 초기화 하고 나머지는 필드 선언시에 초기화 하거나 생성자 내부의 임의의 값 또는 계산된 값으로 초기화하거나, 객체 생성 후에 필드값을 별도로 저장하기도 함.
 *  
 *  
 *  [생성자 오버로딩]
 *  매개변수를 달리하는 생성자를 여러개 선언하는것.
 *   예)
 *   public class Car {
 *   	Car() {}
 *   	Car(String model) {}
 *   	Car(String model, String color) {}
 *   	Car(String model, String color, int maxSpeed) {}
 *   }
 *   오버로딩은 매개변수의 타입과 개수 선언된 순서가 같으면 변수 이름이 바뀌어도 같은걸로 취급함.
 *   타입, 순서가 달라야 오버로딩이 됌.
 *   
 *   다른 생성자 호출 this : 생성자 간의 중복된 코드가 발생할 경우, 필드 초기화 내용을 한 생성자에만 작성하고 this로 호출해서 사용할 수 있음.
 *   this는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 첫줄 에서만 허용됌.
 		 생성자의 첫줄에서만 허용? : this쓰기전에 다른 필드를 초기화 한다음에, 다음줄에 this 쓰는건 안된다는 뜻인듯.
 	
 	[메소드]
 	 객체의 동작에 해당하는 중괄호 {} 블록. 중괄호 블록 이름이 메소드 이름이며, 메소드를 호출하면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행됌.
 	 매소드 선언 : 선언부(리턴타입, 메소드이름, 매개 변수 선언)와 실행 블록으로 구성.
 	  - 리턴타입 : 리턴값의 타입을 말하며 리턴값이란 메소드를 실행한 후의 결과값을 말함. 리턴값은 있/없 이나 있을경우 선언부에 명시되어야함.
 	  리턴값 없을때 호출방법 : powerOn(); {} 
 	  리턴값 있을때 호출방법 : double drive(int x, int y ) {}
 	  
 	  매소드 이름 : 숫자로 시작x, $,_만 가능, 소문자 작성, 단어혼합시 뒤의 단어는 대문자로 시작.
 	  매개 변수 선언 : 메소드가 실행할 때 필요한 데이터를 외부로부터 받기 위해 사용. 필요한 경우가 있고, 필요 없는 경우가 있음.
 	  매개 변수 있는 경우 : double drive(int x, int y) {} -> double result = drive(10, 20);
 	  - 매개 변수의 개수를 모를 경우
 	  	매개 변수를 배열 타입으로 선언한다. int sum1(int[] values) { }
 	  	sum1()메소드를 호출할 때 배열을 넘겨 줌으로서, 배열의 항목 값들을 모두 전달 할 수있음.
 	  	배열을 먼저 생성한다음에 넘겨주지 않고 바로 하려면 int sum2(int ... values) {}
 	   ... 로 선언된 매개 변수의 값은 메소드 호출 시 쉼표로 나열해주면 됌.
 	   int result = sum2(1,2,3);
 	   
 	   [리턴문]
 	   메소드 선언에 타입이 있는 메소드는 반드시 리턴문을 사용해서 리턴값을 지정해야함. 리턴문이 없으면 컴파일 에러가 발생하며, 리턴문이 실행되면 메소드는 즉시 종료됌.
 	   return 리턴값 : 리턴 타입이거나 리턴 타입으로 변환될 수 있어야함.
 	   void 메소드는 리턴값이 없는데 return해주면 메소드 바로 종료.
 	   
 	   
 	  
 * @author KDH
 *
 */

public class MethodSummary {

}
